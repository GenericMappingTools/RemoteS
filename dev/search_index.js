var documenterSearchIndex = {"docs":
[{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#Plot-AQUA-satellite-tracks-1","page":"Aqua orbits","title":"Plot AQUA satellite tracks","text":"","category":"section"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"Compute 1 day of AQUA satellite orbits starting at current local time. Note, this will be accurate for the month of September 2021. For other dates it needs an updated TLE. Note also that repeating the commands below will produce different results since the current local time is used as the starting point.","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"Orbits calculation rely on the SatelliteToolbox package, which is not a direct dependency (meaning, it's not loaded automatically) but need to be installed for this to work. Orbits are calculated with the help of the so called Two Line Element files that unfortunatelly have accuracy validity quite short (around one month). They can be obtainded from the Space Track site.","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"using RemoteS, GMT, SatelliteToolbox\n\n# The AQUA orbits TLE contents for the month of September 2021 \ntle1 = \"1 27424U 02022A   21245.83760660  .00000135  00000-0  39999-4 0  9997\";\ntle2 = \"2 27424  98.2123 186.0654 0002229  67.6025 313.3829 14.57107527 28342\";\norb = sat_tracks(tle=[tle1; tle2], duration=\"1D\");\n\n# The orbit track can be visualized with\nimshow(orb,  proj=:Robinson, region=:global, coast=true)","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"<img src=\"../AQUA_oneday_tracks.png\" width=\"600\" class=\"center\"/>","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"There is no point in plotting orbits for a lengthier duration because they would clutter the figure but we can compute them and display over a specific region on Earth.","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"# Compute orbits during 2 days at 15 seconds intervals\norb = sat_tracks(tle=[tle1; tle2], duration=\"2D\", step=15);\n\n# and plot them on my \"vicinity\"\nD = clip_orbits(orb, [-20, 10, 30, 50]);\n\nimshow(D, proj=:guess, coast=true, dpi=200)","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"<img src=\"../AQUA_twoday_clipped.png\" width=\"500\" class=\"center\"/>","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"And imagine we would like to know the names of the AQUA scene files that cover a certain location? We can do it with the findscenes function to which we must provide the location of interest, the satellite (currently only AQUA or TERRA), the duration of the search and if we want Chlorophyl-a concentration or Sea Surface Temperature (see function help for details).","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"# Get the scene names of data with Chlorophyl-a concentration covering\n# the point (-8,36) and for two days before \"2021-09-07T17:00:00\"\ntle1 = \"1 27424U 02022A   21245.83760660  .00000135  00000-0  39999-4 0  9997\";\ntle2 = \"2 27424  98.2123 186.0654 0002229  67.6025 313.3829 14.57107527 28342\";\nfindscenes(-8,36, start=\"2021-09-07T17:00:00\", sat=:aqua, day=true, duration=-2, oc=1, tle=[tle1, tle2])","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"\t2-element Vector{String}:\n\tA2021251125500.L2_LAC_OC.nc\n\tA2021252134000.L2_LAC_OC.nc","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"Now you can download them from https://oceandata.sci.gsfc.nasa.gov/ob/getfile/A2021251125500.L2_LAC_OC.nc (but you will need to register first) and play with the grid_at_sensor function for interpolation and visualization.","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"Another cool thing we can do is to plot the area extent of the AQUA or TERRA scenes. We do it by first computing and orbit with a start and stop times and with increments of 1 minute (attention, this is an important factor). With that orbit we use the sat_tracks function to compute the polygons delimiting those areas.","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"using Dates\n\norb = sat_tracks(tle=[tle1; tle2], start=DateTime(\"2021-09-02T13:30:00\"),\n\tstop=DateTime(\"2021-09-02T13:40:00\"), step=\"1m\");\n\nDsc = sat_scenes(orb, \"AQUA\");","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"<img src=\"../AQUA_two_scenes.png\" width=\"500\" class=\"center\"/>","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"The scene names are stored in the header field of the Dsc GMTdatset","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"julia> Dsc[1].header\n\n`AQUA_MODIS.20210902T133001.L2.SST.NRT.nc`\n\njulia> Dsc[2].header\n\n`AQUA_MODIS.20210902T133501.L2.SST.NRT.nc`","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"","category":"page"},{"location":"gallery/Aqua_orbits/remotes_sat_tracks/#","page":"Aqua orbits","title":"Aqua orbits","text":"Download a Neptune Notebook here","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#Exploring-a-*cube*-of-Landsat-8-data-1","page":"Landsat 8 images","title":"Exploring a cube of Landsat 8 data","text":"","category":"section"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"Here we will show examples of the type of things we can do with Landsat 8 data stored in a cube for better organisation and easyness of access.","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"The data was downloaded from EarthExplorer and comprises the scene with Product ID LC08_L1TP_204033_20210525_20210529_02_T1.","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"The cube was made with this instructions (but they would only work if you had the scene files in your computer).","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"path = C:/v/LC08_L1TP_204033_20210525_20210529_02_T1/LC08_L1TP_204033_20210525_20210529_02_T1_B;","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"cube = cutcube(bands=[2,3,4,5,6,7,10], template=pato, region=(485490,531060,4283280,4330290), save=\\\"LC08_L1TP_20210525_02_cube.tiff\\\")","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"This creates a 3D GeoTIFF file with the companion MTL file saved in it as Metadata. We can see the band info by running the reportbands function. That information is quite handy because we can, for example, just refer to the red band and it will figure out which layer of the cube contains the Red band.","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"using RemoteS, GMT\nreportbands(\"c:/v/LC08_L1TP_20210525_02_cube.tiff\")\n7-element Vector{String}:\n \"Band 2 - Blue [0.45-0.51]\"\n \"Band 3 - Green [0.53-0.59]\"\n \"Band 4 - Red [0.64-0.67]\"\n \"Band 5 - NIR [0.85-0.88]\"\n \"Band 6 - SWIR 1 [1.57-1.65]\"\n \"Band 7 - SWIR 2 [2.11-2.29]\"\n \"Band 10 - Thermal IR 1 [10.6-11.19]\"","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"So to start our exploration the best is to generate a true color image. The truecolor function knows how to do that automatically including the histogram contrast stretch.","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"Irgb = truecolor(\"c:/v/LC08_L1TP_20210525_02_cube.tiff\");\nimshow(Irgb)","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"<img src=\"../LC08_L1TP_20210525_02_RGB.png\" width=\"500\" class=\"center\"/>","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"And we can compute the brightness temperature in Celsius at the Top of Atmosphere (TOA) from Band 10.","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"T = dn2temperature(\"c:/v/LC08_L1TP_20210525_02_cube.tiff\", band=10);\nimshow(T, dpi=150, colorbar=true)","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"<img src=\"../LC08_L1TP_20210525_02_Tbright.png\" width=\"500\" class=\"center\"/>","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"Or the Radiance TOA for the Blue band.","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"Btoa = dn2radiance(\"c:/v/LC08_L1TP_20210525_02_cube.tiff\", bandname=\"blue\");\nimshow(Btoa, dpi=150, color=:gray)","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"<img src=\"../LC08_L1TP_20210525_02_Gtoa.png\" width=\"500\" class=\"center\"/>","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"Hmmm, very dark. Let's look at its histogram.","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"histogram(Gtoa, show=1)","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"<img src=\"../LC08_L1TP_20210525_02_Gtoa_histo.png\" width=\"350\" class=\"center\"/>","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"Yes, the data is very concentraded in the low numbers. We will need to apply a contrast stretch.","category":"page"},{"location":"gallery/L8cube_img/remotes_L8_cube_img/#","page":"Landsat 8 images","title":"Landsat 8 images","text":"To be continued.","category":"page"},{"location":"gallery/Aqua_sst/remotes_L2_SST/#Interpolate-a-MODIS-L2-SST-file-1","page":"Aqua SST","title":"Interpolate a MODIS L2 SST file","text":"","category":"section"},{"location":"gallery/Aqua_sst/remotes_L2_SST/#","page":"Aqua SST","title":"Aqua SST","text":"The Level 2 MODIS files are the ones that contain the information at its maximum spatial resolution. However, in those products the data is not equally spaced so we must interpolate it first before use. The grid_at_sensor function provides a handy interface to do it easily.","category":"page"},{"location":"gallery/Aqua_sst/remotes_L2_SST/#","page":"Aqua SST","title":"Aqua SST","text":"Imagine that you have downloaded the file AQUA_MODIS.20210805T131001.L2.SST.NRT.nc from the OceanColor site (eventually following the example in Plot AQUA satellite tracks)","category":"page"},{"location":"gallery/Aqua_sst/remotes_L2_SST/#","page":"Aqua SST","title":"Aqua SST","text":"using RemoteS, GMT\n\n# Interpolate from sensor to geographic coordinates at approx 1 km grid steps\nG = grid_at_sensor(\"C:/v/AQUA_MODIS.20210805T131001.L2.SST.NRT.nc\", \"sst\", inc=0.01);\n\n# Display it\nimshow(G, proj=:guess, coast=true, dpi=200)","category":"page"},{"location":"gallery/Aqua_sst/remotes_L2_SST/#","page":"Aqua SST","title":"Aqua SST","text":"<img src=\"../AQUA_SST_1km.png\" width=\"600\" class=\"center\"/>","category":"page"},{"location":"gallery/Aqua_sst/remotes_L2_SST/#","page":"Aqua SST","title":"Aqua SST","text":"Note that since we used a grid step 0f 0.01 for the interpolation and this value is very close to the MODIS maximum spatial resolution, the left and right regions have beam spacings 2 to 5 times this and show many little holes. Do not confuse these little holes with the larger ones that are caused by cloud coverage. So we will recalculate the grid at increments of ~2 km and over the region that has the higher data density.","category":"page"},{"location":"gallery/Aqua_sst/remotes_L2_SST/#","page":"Aqua SST","title":"Aqua SST","text":"# Recompue at a inc=0.02 and over a sub-region\nG = grid_at_sensor(\"C:/v/AQUA_MODIS.20210805T131001.L2.SST.NRT.nc\", \"sst\", region=(-13,10,33.8,44.5), inc=0.02);","category":"page"},{"location":"gallery/Aqua_sst/remotes_L2_SST/#","page":"Aqua SST","title":"Aqua SST","text":"# Make a nicer image with illumination.\nimshow(G, proj=:guess, coast=true, shade=true, title=\"Sea Surace Temperature\", colorbar=true)","category":"page"},{"location":"gallery/Aqua_sst/remotes_L2_SST/#","page":"Aqua SST","title":"Aqua SST","text":"<img src=\"../AQUA_SST_2km.png\" width=\"600\" class=\"center\"/>","category":"page"},{"location":"gallery/Aqua_sst/remotes_L2_SST/#","page":"Aqua SST","title":"Aqua SST","text":"","category":"page"},{"location":"gallery/Aqua_sst/remotes_L2_SST/#","page":"Aqua SST","title":"Aqua SST","text":"Download a Neptune Notebook here","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#Spectral-indices-with-Landsat-8-imagery-1","page":"Landsat 8 NDVI","title":"Spectral indices with Landsat 8 imagery","text":"","category":"section"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"We will use here the same data cube that was introduced in the images example.","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"A very popular spectral indice is the NDVI which is deffined as the a normalized difference between the Near Infra Red (NIR) and the Red bands. Namely NDVI = (NIR - Red) / (NIR + Red). An heuristic says that NDVI values ~greater than 0.4 indicate green vegetation as higher the indice (maximum = 1) larger is the green vegetation content.","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"Since the data cube holds in it the information about each band, computing the NDVI is a trivial opration because we known where each band is in the data cube. Let's see it.","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"using RemoteS, GMT\nN = ndvi(\"c:/v/LC08_L1TP_20210525_02_cube.tiff\");\nimshow(N, colorbar=true)","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"<img src=\"../LC08_L1TP_20210525_02_NDVI_raw.png\" width=\"500\" class=\"center\"/>","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"The spectral indices functions all have a threshold value that will NaNify all values  threshold. Below we wipe out all values < 0.4 to show only the Green stuff","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"N = ndvi(\"c:/v/LC08_L1TP_20210525_02_cube.tiff\", threshold=0.4);\nimshow(N, dpi=150, colorbar=1)","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"<img src=\"../LC08_L1TP_20210525_02_NDVI_04.png\" width=\"500\" class=\"center\"/>","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"Cool but I would like to check that the result is correct.","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"The spectral indices functions have another option to obtain just a mask where the values are  threshold, so we can use it to mask out the true color image and see what we get. ","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"# Compute a mask based on the condition that threshold >= 0.4\nmask = ndvi(\"c:/v/LC08_L1TP_20210525_02_cube.tiff\", threshold=0.4, mask=true);","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"To mask out the true color image the best way is to use the mask as the alpha band. To make it easier we will recalculate the true color image here.","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"# Recalculate the true color image\nIrgb = truecolor(\"c:/v/LC08_L1TP_20210525_02_cube.tiff\");\n\n# Apply the mask\nimage_alpha!(Irgb, mask);\n\n# And save it to disk so that we can visualize the result\ngmtwrite(\"c:/v/rgb_masked.tiff\", Irgb)\n\nimshow(\"c:/v/rgb_masked.tiff\")","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"<img src=\"../LC08_L1TP_20210525_02_RGB_masked.png\" width=\"500\" class=\"center\"/>","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"While we can see that only the green color is present in the above image, it's not easy to see the details. So let's zoom in but do also another thing. Let us see also what parts of the RGB image were not selected. To see that we will calculate the inverse mask, that is, the mask that retains all values < threshold. To achieve that we use the mask option with a negative number.","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"# Compute a mask based on the condition that threshold >= 0.4\nmask_inv = ndvi(\"c:/v/LC08_L1TP_20210525_02_cube.tiff\", threshold=0.4, mask=-1);\nimage_alpha!(Irgb, mask_inv);\ngmtwrite(\"c:/v/rgb_inv_masked.tiff\", Irgb)","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"Plot the green vegetation that passed the NDVI threshold test and the other part, side by side.","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"grdimage(\"c:/v/rgb_masked.tiff\", region=(502380,514200,4311630,4321420), figsize=8, frame=:bare)\ngrdimage!(\"c:/v/rgb_inv_masked.tiff\", figsize=8, projection=:linear, xshift=8, frame=:bare, show=true)","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"<img src=\"../LC08_L1TP_20210525_02_RGB_masked2.jpg\" width=\"600\" class=\"center\"/>","category":"page"},{"location":"gallery/L8cube_ndvi/remotes_L8_NDVI/#","page":"Landsat 8 NDVI","title":"Landsat 8 NDVI","text":"As we can see only the greenest part, the one that is probably more irrigated considering that all the river and cannals margins were retained, was extracted with the condition NDVI > 0.4. Off course, using different threshold values would lead to slightly different results.","category":"page"},{"location":"#RemoteS-1","page":"Index","title":"RemoteS","text":"","category":"section"},{"location":"#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"#","page":"Index","title":"Index","text":"Modules = [RemoteS]\nOrder   = [:function, :type, :module]","category":"page"},{"location":"#Functions-1","page":"Index","title":"Functions","text":"","category":"section"},{"location":"#","page":"Index","title":"Index","text":"Modules = [RemoteS]\nOrder   = [:function, :type, :module]","category":"page"},{"location":"#RemoteS.clg-Tuple{Any, Any}","page":"Index","title":"RemoteS.clg","text":"CLG = clg(green, redEdge3; kw...)\n\nGreen cholorphyl index. Wu et al 2012.\n\nCLG = (redEdge3)/(green)-1 \n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.clre-Tuple{Any, Any}","page":"Index","title":"RemoteS.clre","text":"CLRE = clre(redEdge1, redEdge3; kw...)\n\nRedEdge cholorphyl index. Clevers and Gitelson 2013.\n\nCLRE = (redEdge3)/(redEdge1)-1\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.cutcube-Tuple{}","page":"Index","title":"RemoteS.cutcube","text":"cutcube(names=String[], bands=Int[], template=\"\", region=nothing, extension=\".TIF\", description=String[], mtl=\"\", sentinel2=0, save=\"\")\n\nCut a 3D cube out of a Landsat/Sentinel scene within a subregion region and a selection of bands.\n\nnames: (optional) A vector with the individual bands full file name\nbands: When names is not provided give a vector of integers corresponding to the choosen bands.          This works well for Landsat and most of Sentinel bands. However, in later case, there are also          bands that contain characters, for example band 8A. In this case bands should be a vector of          strings including the extension. e.g. [\"02.jp2\", \"8A.jp2\"]\ntemplate: Goes together with the bands option. They are both composed a template * band[n] to recreate          the full file name of each band.\nregion Is the region to extract and must contain the extracting region limits as [W, E, S, N] or a          GMT style -R string (without the leading \"-R\").\nextension: In case the bands is numeric but file extensions are not \"*.TIF\" (case insensitive),          use the extension passed by this option.\ndescription: A vector of strings (as many as bands) with a description for each band. If not provided and          the file is recognized as a Landasat 8, band description is added automatically, otherwise          we build one with the bands file names. This info will saved if data is written to a file.\nmtl:   If reading from Landsat and the MTL file is not automatically found (you get an error) use this          option to pass the full name of the MTL file.\nsentinel2: ESA is just unconsistent and names change with time and band numbers can have character (e.g. 8A)          hence we need help to recognize Sentinel files so the known description can be assigned.          Use sentinel=10, or =20 or =60 to indicate Sentinel files at those resolutions.\nsave:  The file name where to save the output. If not provided, a GMTimage is returned.\n\nReturn: nothing if the result is written in file or a GMTimage otherwise.\n\nExamples\n\n# Cut a Landsat 8 scene for a small region (in UTM) and return a GMTimage with 3 bands in UInt16.\ntemp = \"C:\\SIG_AnaliseDadosSatelite\\SIG_ADS\\DadosEx2\\LC82040332015145LGN00\\LC82040332015145LGN00_B\";\ncube = cutcube(bands=[2,3,4], template=temp, region=[479670,492720,4282230,4294500])\n\n# The same example as above but save the data in a GeoTIFF disk file and use a string for `region`\ncutcube(bands=[2,3,4], template=temp, region=\"479670/492720/4282230/4294500\", save=\"landsat_cube.tif\")\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.dn2radiance-Tuple{String}","page":"Index","title":"RemoteS.dn2radiance","text":"R = dn2radiance(fname::String, [band::Int, bandname::String, mtl::String])\n\nComputes the radiance at TopOfAtmosphere of a Landsat 8 file\n\nfname: The name of either a LANDSAT_PRODUCT_ID geotiff band, or the name of a cube file created with the cutcube function. In the first case, if the companion MTLtxt file is not in the same directory as fname one can still pass it via the mtl=path-to-MTL-file option. In the second case it is mandatory to use one of the following two options.\nband: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when band is used we search for the band named \"Band N\", where N = band.\nbandname: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandname string that will be matched against the cube's bands descriptions. We can use the reportbands function to see the bands description.\n\nReturns a Float32 GMTgrid\n\nExample:\n\nCompute the radiance TOA of Band 2 file.\n\nR = dn2temperature(\"LC08_L1TP_204033_20210525_20210529_02_T1_B2.TIF\")\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.dn2reflectance-Tuple{String}","page":"Index","title":"RemoteS.dn2reflectance","text":"R = dn2reflectance(fname::String, [band::Int, bandname::String, mtl::String])\n\nComputes the TopOfAtmosphere planetary reflectance of a Landsat8 file\n\nfname: The name of either a LANDSAT_PRODUCT_ID geotiff band, or the name of a cube file created with the cutcube function. In the first case, if the companion MTLtxt file is not in the same directory as fname one can still pass it via the mtl=path-to-MTL-file option. In the second case it is mandatory to use one of the following two options.\nband: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when band is used we search for the band named \"Band N\", where N = band.\nbandname: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandname string that will be matched against the cube's bands descriptions. We can use the reportbands function to see the bands description.\n\nReturns a Float32 GMTgrid\n\nExample:\n\nCompute the reflectance TOA of Red Band stored in a cube\n\nR = dn2reflectance(cube, bandname=\"red\")\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.dn2temperature-Tuple{String}","page":"Index","title":"RemoteS.dn2temperature","text":"R = dn2temperature(fname::String; band::Int=0, mtl::String=\"\")\n\nComputes the brigthness temperature of Landasat8 termal band (10 or 11)\n\nfname: The name of either a LANDSAT_PRODUCT_ID geotiff band, or the name of a cube file created with the cutcube function. In the first case, if the companion MTLtxt file is not in the same directory as fname one can still pass it via the mtl=path-to-MTL-file option. In the second case it is mandatory to use one of the following two options.\nband: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when band is used we search for the band named \"Band N\", where N = band.\nbandname: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandname string that will be matched against the cube's bands descriptions. We can use the reportbands function to see the bands description.\n\nReturns a Float32 GMTgrid\n\nExample:\n\nCompute the brightness temperature of Band 10 stored in a cube\n\nT = dn2temperature(cube, band=10)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.evi-Tuple{Any, Any, Any}","page":"Index","title":"RemoteS.evi","text":"EVI = evi(blue, red, nir; kw...)\n\nor\n\nEVI = evi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)\n\nEnhanced vegetation index. Huete et al 1990\n\nEVI = G * ((nir - red) / (nir + C1 * red - C2 * blue + Levi)); C1, C2, G, Levi = 6.0, 7.5, 2.5, 1.\n\nThe first form accepts inputs as matrices, or file names of the data bands.\nThe second form is more versatile but also more complex to describe.\ncube: Is the file name of a 'cube', a multi-layered file normally created with the cutcube function.  If this file was created with band descriptions one can use the bands or the bandnames options.\nbands: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when bands is used we search for bands named \"Band band[k]\", where band[k] loops over all elements of the bands vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, i.e. like the example for the first form.\nlayers: Use this option when you are certain of the bands order in the cube or the it doesn't have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.\nbandnames: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandnames string vector that will be matched against the cube's bands descriptions.\nkwargs:\nthreshold: When a threshold is provided we return a GMTgrid where vals[ij] < threshold = NaN\nclasses: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] > classes[1] = 1; vals[ij] > classes[2] = 2; vals[ij] > classes[3] = 3 and 0 otherwise.\nmask: Used together with threshold outputs a UInt8 GMTimage mask with vals[ij] >= threshold = 255 and 0 otherwise  If mask=-1 (or any other negative number) we compute instead a mask where vals[ij] < threshold = 255 and 0 otherwise\nsave: Use save=\"file_name.ext\" to save the result in a disk file. File format is picked from file extension.\n\nIf none of bands, layers or bandnames is provided, we use the default band names shown in the first form.\n\nSee also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.\n\nReturns either a Float32 GMTgrid or a UInt8 GMTimage if the mask or classes options are used.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.evi2-Tuple{Any, Any}","page":"Index","title":"RemoteS.evi2","text":"EVI2 = evi2(red, nir; kw...)\n\nor\n\nEVI2 = evi2(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)\n\nTwo-band Enhanced vegetation index. Jiang et al 2008\n\nEVI2 = G * ((nir - red) / (nir + 2.4 * red ))\n\nThe first form accepts inputs as matrices, or file names of the data bands.\nThe second form is more versatile but also more complex to describe.\ncube: Is the file name of a 'cube', a multi-layered file normally created with the cutcube function.  If this file was created with band descriptions one can use the bands or the bandnames options.\nbands: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when bands is used we search for bands named \"Band band[k]\", where band[k] loops over all elements of the bands vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, i.e. like the example for the first form.\nlayers: Use this option when you are certain of the bands order in the cube or the it doesn't have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.\nbandnames: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandnames string vector that will be matched against the cube's bands descriptions.\nkwargs:\nthreshold: When a threshold is provided we return a GMTgrid where vals[ij] < threshold = NaN\nclasses: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] > classes[1] = 1; vals[ij] > classes[2] = 2; vals[ij] > classes[3] = 3 and 0 otherwise.\nmask: Used together with threshold outputs a UInt8 GMTimage mask with vals[ij] >= threshold = 255 and 0 otherwise  If mask=-1 (or any other negative number) we compute instead a mask where vals[ij] < threshold = 255 and 0 otherwise\nsave: Use save=\"file_name.ext\" to save the result in a disk file. File format is picked from file extension.\n\nIf none of bands, layers or bandnames is provided, we use the default band names shown in the first form.\n\nSee also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.\n\nReturns either a Float32 GMTgrid or a UInt8 GMTimage if the mask or classes options are used.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.gndvi-Tuple{Any, Any}","page":"Index","title":"RemoteS.gndvi","text":"GNDVI = gndvi(green, nir; kw...)\n\nor\n\nGNDVI = gndvi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)\n\ngreen Normalized diff vegetation index: more sensitive to cholorphyll than ndvi. Gitelson, A., and M. Merzlyak\n\nGNDVI = (nir - green) / (nir + green)\n\nThe first form accepts inputs as matrices, or file names of the data bands.\nThe second form is more versatile but also more complex to describe.\ncube: Is the file name of a 'cube', a multi-layered file normally created with the cutcube function.  If this file was created with band descriptions one can use the bands or the bandnames options.\nbands: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when bands is used we search for bands named \"Band band[k]\", where band[k] loops over all elements of the bands vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, i.e. like the example for the first form.\nlayers: Use this option when you are certain of the bands order in the cube or the it doesn't have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.\nbandnames: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandnames string vector that will be matched against the cube's bands descriptions.\nkwargs:\nthreshold: When a threshold is provided we return a GMTgrid where vals[ij] < threshold = NaN\nclasses: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] > classes[1] = 1; vals[ij] > classes[2] = 2; vals[ij] > classes[3] = 3 and 0 otherwise.\nmask: Used together with threshold outputs a UInt8 GMTimage mask with vals[ij] >= threshold = 255 and 0 otherwise  If mask=-1 (or any other negative number) we compute instead a mask where vals[ij] < threshold = 255 and 0 otherwise\nsave: Use save=\"file_name.ext\" to save the result in a disk file. File format is picked from file extension.\n\nIf none of bands, layers or bandnames is provided, we use the default band names shown in the first form.\n\nSee also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.\n\nReturns either a Float32 GMTgrid or a UInt8 GMTimage if the mask or classes options are used.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.grid_at_sensor","page":"Index","title":"RemoteS.grid_at_sensor","text":"G = grid_at_sensor(fname::String, sds_name::String=\"\"; V::Bool=false, kw...)\n\nRead one of those netCDF files that are not regular grids but have instead the coordinates in the LONGITUDE abd LATITUDE arrays. MODIS L2 files are a good example of this. Data in theses files are not layed down on a regular grid and we must interpolate to get one. Normally the lon and lat arrays are called 'longitude' and 'latitude' and these it's what is seek for by default. But files exist that pretend to comply to CF but use other names. In this case, use the kwargs xarray & yarray to pass in the variable names. For example: xarray=\"XLONG\", yarray=\"XLAT\" The other fundamental info to pass in is the name of the array to be read/interpolated. We do that via the sds_name arg.\n\nIn simpler cases the variable to be interpolated lays down on a 2D array but it is also possible that it is stored in a 3D array. If that is the case, use the keyword 'band' to select a band (ex: 'band=2') Bands are numbered from 1.\n\nThe interpolation is done so far with 'nearneighbor'. Both the region (-R) and increment (-I) are estimated from data but they can be set with region and inc kwargs as well. For MODIS data we can select the quality flag to filter by data quality. By default the best quality (=0) is used, but one can select another with the quality=val kwarg. Positive 'val' values select data of quality <= quality, whilst negative 'val' values select only data with quality >= abs(val). This allows for example to extract only the cloud coverage.\n\nIf instead of calculating a grid (returned as a GMTgrid type) user wants the x,y,z data intself, use the keywords dataset, or outxyz and the output will be in a GMTdataset (i.e. use dataset=true).\n\nTo inquire just the list of available arrays use list=true or gdalinfo=true to get the full file info.\n\nExamples:\n\nG = grid_at_sensor(\"AQUA_MODIS.20020717T135006.L2.SST.nc\", \"sst\", V=true);\n\nG = grid_at_sensor(\"TXx-narr-annual-timavg.nc\", \"T2MAX\", xarray=\"XLONG\", yarray=\"XLAT\", V=true);\n\n\n\n\n\n","category":"function"},{"location":"#RemoteS.mndwi-Tuple{Any, Any}","page":"Index","title":"RemoteS.mndwi","text":"MNDWI = mndwi(green, swir2; kw...)\n\nor\n\nMNDWI = mndwi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)\n\nModified Normalised Difference Water Index. Xu2006\n\nMNDWI = (green-swir2) / (green+swir2)\n\nThe first form accepts inputs as matrices, or file names of the data bands.\nThe second form is more versatile but also more complex to describe.\ncube: Is the file name of a 'cube', a multi-layered file normally created with the cutcube function.  If this file was created with band descriptions one can use the bands or the bandnames options.\nbands: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when bands is used we search for bands named \"Band band[k]\", where band[k] loops over all elements of the bands vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, i.e. like the example for the first form.\nlayers: Use this option when you are certain of the bands order in the cube or the it doesn't have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.\nbandnames: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandnames string vector that will be matched against the cube's bands descriptions.\nkwargs:\nthreshold: When a threshold is provided we return a GMTgrid where vals[ij] < threshold = NaN\nclasses: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] > classes[1] = 1; vals[ij] > classes[2] = 2; vals[ij] > classes[3] = 3 and 0 otherwise.\nmask: Used together with threshold outputs a UInt8 GMTimage mask with vals[ij] >= threshold = 255 and 0 otherwise  If mask=-1 (or any other negative number) we compute instead a mask where vals[ij] < threshold = 255 and 0 otherwise\nsave: Use save=\"file_name.ext\" to save the result in a disk file. File format is picked from file extension.\n\nIf none of bands, layers or bandnames is provided, we use the default band names shown in the first form.\n\nSee also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.\n\nReturns either a Float32 GMTgrid or a UInt8 GMTimage if the mask or classes options are used.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.msavi-Tuple{Any, Any}","page":"Index","title":"RemoteS.msavi","text":"MSAVI = msavi(red, nir; kw...)\n\nor\n\nMSAVI = msavi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)\n\nModified soil adjusted vegetation index. Qi 1994\n\nMSAVI = nir + 0.5 - (0.5 * sqrt(pow(2.0 * nir + 1.0, 2) - 8.0 * (nir - (2.0 * red))))\n\nThe first form accepts inputs as matrices, or file names of the data bands.\nThe second form is more versatile but also more complex to describe.\ncube: Is the file name of a 'cube', a multi-layered file normally created with the cutcube function.  If this file was created with band descriptions one can use the bands or the bandnames options.\nbands: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when bands is used we search for bands named \"Band band[k]\", where band[k] loops over all elements of the bands vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, i.e. like the example for the first form.\nlayers: Use this option when you are certain of the bands order in the cube or the it doesn't have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.\nbandnames: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandnames string vector that will be matched against the cube's bands descriptions.\nkwargs:\nthreshold: When a threshold is provided we return a GMTgrid where vals[ij] < threshold = NaN\nclasses: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] > classes[1] = 1; vals[ij] > classes[2] = 2; vals[ij] > classes[3] = 3 and 0 otherwise.\nmask: Used together with threshold outputs a UInt8 GMTimage mask with vals[ij] >= threshold = 255 and 0 otherwise  If mask=-1 (or any other negative number) we compute instead a mask where vals[ij] < threshold = 255 and 0 otherwise\nsave: Use save=\"file_name.ext\" to save the result in a disk file. File format is picked from file extension.\n\nIf none of bands, layers or bandnames is provided, we use the default band names shown in the first form.\n\nSee also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.\n\nReturns either a Float32 GMTgrid or a UInt8 GMTimage if the mask or classes options are used.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.mtci-Tuple{Any, Any, Any}","page":"Index","title":"RemoteS.mtci","text":"MTCI = mtci(red, redEdge1, redEdge2; kw...)\n\nMeris Terrestrial Chlorophyll Index. Clevers and Gitelson 2013, Dash and Curran 2004\n\nMTCI = (redEdge2-redEdge1) / (redEdge1-red)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.ndrei1-Tuple{Any, Any}","page":"Index","title":"RemoteS.ndrei1","text":"NDREI1 = ndrei1(redEdge1, redEdge2; kw...)\n\nNormalized difference red edge index. Gitelson and Merzlyak 1994\n\nNDREI1 = (redEdge2 - redEdge1) / (redEdge2 + redEdge1)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.ndrei2-Tuple{Any, Any}","page":"Index","title":"RemoteS.ndrei2","text":"NDREI2 = ndrei2(redEdge1, redEdge3; kw...)\n\nNormalized difference red edge index 2. Barnes et al 2000\n\nNDREI2 = (redEdge3 - redEdge1) / (redEdge3 + redEdge1)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.ndvi-Tuple{Any, Any}","page":"Index","title":"RemoteS.ndvi","text":"NDVI = ndvi(red, nir; kw...)\n\nor\n\nNDVI = ndvi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)\n\nCompute the NDVI vegetation index. Input can be either the bands file names, or GMTimage objects with the band's data.\n\nNDVI = (nir - red) / (nir + red)\n\nThe first form accepts inputs as matrices, or file names of the data bands.\nThe second form is more versatile but also more complex to describe.\ncube: Is the file name of a 'cube', a multi-layered file normally created with the cutcube function.  If this file was created with band descriptions one can use the bands or the bandnames options.\nbands: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when bands is used we search for bands named \"Band band[k]\", where band[k] loops over all elements of the bands vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, i.e. like the example for the first form.\nlayers: Use this option when you are certain of the bands order in the cube or the it doesn't have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.\nbandnames: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandnames string vector that will be matched against the cube's bands descriptions.\nkwargs:\nthreshold: When a threshold is provided we return a GMTgrid where vals[ij] < threshold = NaN\nclasses: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] > classes[1] = 1; vals[ij] > classes[2] = 2; vals[ij] > classes[3] = 3 and 0 otherwise.\nmask: Used together with threshold outputs a UInt8 GMTimage mask with vals[ij] >= threshold = 255 and 0 otherwise  If mask=-1 (or any other negative number) we compute instead a mask where vals[ij] < threshold = 255 and 0 otherwise\nsave: Use save=\"file_name.ext\" to save the result in a disk file. File format is picked from file extension.\n\nIf none of bands, layers or bandnames is provided, we use the default band names shown in the first form.\n\nSee also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.\n\nReturns either a Float32 GMTgrid or a UInt8 GMTimage if the mask or classes options are used.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.ndwi-Tuple{Any, Any}","page":"Index","title":"RemoteS.ndwi","text":"NDWI = ndwi(green, nir; kw...)\n\nor\n\nNDWI = ndwi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)\n\nNormalized difference water index. McFeeters 1996. NDWI => (green - nir)/(green + nir)\n\nNDWI = (green - nir)/(green + nir)\n\nThe first form accepts inputs as matrices, or file names of the data bands.\nThe second form is more versatile but also more complex to describe.\ncube: Is the file name of a 'cube', a multi-layered file normally created with the cutcube function.  If this file was created with band descriptions one can use the bands or the bandnames options.\nbands: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when bands is used we search for bands named \"Band band[k]\", where band[k] loops over all elements of the bands vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, i.e. like the example for the first form.\nlayers: Use this option when you are certain of the bands order in the cube or the it doesn't have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.\nbandnames: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandnames string vector that will be matched against the cube's bands descriptions.\nkwargs:\nthreshold: When a threshold is provided we return a GMTgrid where vals[ij] < threshold = NaN\nclasses: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] > classes[1] = 1; vals[ij] > classes[2] = 2; vals[ij] > classes[3] = 3 and 0 otherwise.\nmask: Used together with threshold outputs a UInt8 GMTimage mask with vals[ij] >= threshold = 255 and 0 otherwise  If mask=-1 (or any other negative number) we compute instead a mask where vals[ij] < threshold = 255 and 0 otherwise\nsave: Use save=\"file_name.ext\" to save the result in a disk file. File format is picked from file extension.\n\nIf none of bands, layers or bandnames is provided, we use the default band names shown in the first form.\n\nSee also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.\n\nReturns either a Float32 GMTgrid or a UInt8 GMTimage if the mask or classes options are used.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.ndwi2-Tuple{Any, Any}","page":"Index","title":"RemoteS.ndwi2","text":"NDWI2 = ndwi2(nir, swir2; kw...)\n\nor\n\nNDWI2 = ndwi2(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)\n\nNormalized difference water index. Gao 1996, Chen 2005 (also known as Normalized Difference Moisture Index NDBI and LSWI)\n\nNDWI2 = (nir - swir2)/(nir + swir2)\n\nThe first form accepts inputs as matrices, or file names of the data bands.\nThe second form is more versatile but also more complex to describe.\ncube: Is the file name of a 'cube', a multi-layered file normally created with the cutcube function.  If this file was created with band descriptions one can use the bands or the bandnames options.\nbands: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when bands is used we search for bands named \"Band band[k]\", where band[k] loops over all elements of the bands vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, i.e. like the example for the first form.\nlayers: Use this option when you are certain of the bands order in the cube or the it doesn't have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.\nbandnames: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandnames string vector that will be matched against the cube's bands descriptions.\nkwargs:\nthreshold: When a threshold is provided we return a GMTgrid where vals[ij] < threshold = NaN\nclasses: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] > classes[1] = 1; vals[ij] > classes[2] = 2; vals[ij] > classes[3] = 3 and 0 otherwise.\nmask: Used together with threshold outputs a UInt8 GMTimage mask with vals[ij] >= threshold = 255 and 0 otherwise  If mask=-1 (or any other negative number) we compute instead a mask where vals[ij] < threshold = 255 and 0 otherwise\nsave: Use save=\"file_name.ext\" to save the result in a disk file. File format is picked from file extension.\n\nIf none of bands, layers or bandnames is provided, we use the default band names shown in the first form.\n\nSee also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.\n\nReturns either a Float32 GMTgrid or a UInt8 GMTimage if the mask or classes options are used.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.reflectance_surf-Tuple{String}","page":"Index","title":"RemoteS.reflectance_surf","text":"R = reflectance_surf(fname::String, [band::Int, bandname::String, mtl::String])\n\nComputes the radiance-at-surface of Landsat8 band using the COST model.\n\nfname: The name of either a LANDSAT_PRODUCT_ID geotiff band, or the name of a cube file created with the cutcube function. In the first case, if the companion MTLtxt file is not in the same directory as fname one can still pass it via the mtl=path-to-MTL-file option. In the second case it is mandatory to use one of the following two options.\nband: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when band is used we search for the band named \"Band N\", where N = band.\nbandname: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandname string that will be matched against the cube's bands descriptions. We can use the reportbands function to see the bands description.\n\nReturns a Float32 GMTgrid\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.reportbands-Tuple{Any, Int64}","page":"Index","title":"RemoteS.reportbands","text":"reportbands(in; [layers=Int[]])\n\nor\n\nreportbands(in, layer;)\n\nReport the Bands description of the in input argument. This can be a GMTimage or a file name (a String) of  a 'cube' file. Normally one made with the cutcube function. When the use conditions of this function are not met, either a warning or an error message (if too deep to be caught as a warning) will be issued.\n\nlayers: When this optional parameter is used, report the description of the bands in the vector layers\nlayer: A scalar with a unique band number. Alternative form to reportbands(in, layers=[layer])\n\nReturns a string vector.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.satvi-Tuple{Any, Any, Any}","page":"Index","title":"RemoteS.satvi","text":"SATVI = satvi(red, swir2, swir3; kw...)\n\nSoil adjusted total vegetation index. Marsett 2006\n\nSATVI = ((swir1 - red) / (swir1 + red + L)) * (1.0 + L) - (swir2 / 2.0)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.savi-Tuple{Any, Any}","page":"Index","title":"RemoteS.savi","text":"SAVI = savi(red, nir; kw...)\n\nor\n\nSAVI = savi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)\n\nSoil adjusted vegetation index. Huete 1988\n\nSAVI = (nir - red) * (1.0 + L) / (nir + red + L)\n\nThe first form accepts inputs as matrices, or file names of the data bands.\nThe second form is more versatile but also more complex to describe.\ncube: Is the file name of a 'cube', a multi-layered file normally created with the cutcube function.  If this file was created with band descriptions one can use the bands or the bandnames options.\nbands: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when bands is used we search for bands named \"Band band[k]\", where band[k] loops over all elements of the bands vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, i.e. like the example for the first form.\nlayers: Use this option when you are certain of the bands order in the cube or the it doesn't have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.\nbandnames: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandnames string vector that will be matched against the cube's bands descriptions.\nkwargs:\nthreshold: When a threshold is provided we return a GMTgrid where vals[ij] < threshold = NaN\nclasses: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] > classes[1] = 1; vals[ij] > classes[2] = 2; vals[ij] > classes[3] = 3 and 0 otherwise.\nmask: Used together with threshold outputs a UInt8 GMTimage mask with vals[ij] >= threshold = 255 and 0 otherwise  If mask=-1 (or any other negative number) we compute instead a mask where vals[ij] < threshold = 255 and 0 otherwise\nsave: Use save=\"file_name.ext\" to save the result in a disk file. File format is picked from file extension.\n\nIf none of bands, layers or bandnames is provided, we use the default band names shown in the first form.\n\nSee also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.\n\nReturns either a Float32 GMTgrid or a UInt8 GMTimage if the mask or classes options are used.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.slavi-Tuple{Any, Any, Any}","page":"Index","title":"RemoteS.slavi","text":"SLAVI = slavi(red, nir, swir2; kw...)\n\nor\n\nSLAVI = slavi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)\n\nSpecific Leaf Area Vegetation Index. Lymburger 2000\n\nSLAVI = nir / (red + swir2)\n\nThe first form accepts inputs as matrices, or file names of the data bands.\nThe second form is more versatile but also more complex to describe.\ncube: Is the file name of a 'cube', a multi-layered file normally created with the cutcube function.  If this file was created with band descriptions one can use the bands or the bandnames options.\nbands: cubes created with cutcube assign descriptions starting with \"Band 1 ...\" an so on the other bands. So when bands is used we search for bands named \"Band band[k]\", where band[k] loops over all elements of the bands vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, i.e. like the example for the first form.\nlayers: Use this option when you are certain of the bands order in the cube or the it doesn't have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.\nbandnames: When we know the common designation of a band, for example \"Green\", or any part of a band description, for example \"NIR\", we can use that info to create a bandnames string vector that will be matched against the cube's bands descriptions.\nkwargs:\nthreshold: When a threshold is provided we return a GMTgrid where vals[ij] < threshold = NaN\nclasses: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] > classes[1] = 1; vals[ij] > classes[2] = 2; vals[ij] > classes[3] = 3 and 0 otherwise.\nmask: Used together with threshold outputs a UInt8 GMTimage mask with vals[ij] >= threshold = 255 and 0 otherwise  If mask=-1 (or any other negative number) we compute instead a mask where vals[ij] < threshold = 255 and 0 otherwise\nsave: Use save=\"file_name.ext\" to save the result in a disk file. File format is picked from file extension.\n\nIf none of bands, layers or bandnames is provided, we use the default band names shown in the first form.\n\nSee also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.\n\nReturns either a Float32 GMTgrid or a UInt8 GMTimage if the mask or classes options are used.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.subcube-Tuple{String}","page":"Index","title":"RemoteS.subcube","text":"subcube(cube::String; bands=Int[], bandnames=String[], layers=Int[])\n\nExtracts a subcube from cube with the layers in the bands vector, case in which we will search for bands named \"Band band[k]\", or those whose names correspond (even partially and case insensitive) to the descriptions in bandnames string vector. This means that the options bands and bandnames can only be used in 'cubes' with bands description. The layers option blindly extract the cube planes listed in the layer vector.\n\nReturns a GMTimage\n\nExample\n\nExtracts the Red, Green and Blue layers from a Landsat 8 cube created with cutcube\n\nIrgb = subcube(\"LC08__cube.tiff\", bandnames = [\"red\", \"green\", \"blue\"])\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.truecolor-Tuple{Any, Any, Any}","page":"Index","title":"RemoteS.truecolor","text":"Irgb = truecolor(bndR, bndG, bndB)\n\nTake three Landsat8/Sentinel2 UINT16 GMTimages or the file names of those bands and compose an RGB true color image applying automatic histogram stretching.\n\nReturn an UInt8 RGB GMTimage\n\nIrgb = truecolor(cube::GMTImage, bands::Vector{Int})\n\nMake an RGB composition of the 3 bands passed in the vector 'bands' from the layers in the multi-layered GMTimage cube\n\nReturn an auto-stretched UInt8 RGB GMTimage\n\nIrgb = truecolor(cube::String, [bands::Vector{Int}], [bandnames::Vector{String}], [raw=false])\n\nMake an RGB composition of 3 bands from the cube file holding a UInt16 multi-layered array (often created with cutcube) The band selection can be made with bands vector, case in which we will search for bands named \"Band band[k]\" or where the bands description contain the contents of bandnames. If none of bands or bandnames is used we search for a made up bandnames=[\"red\", \"green\", \"blue\"].\n\nReturn an auto-stretched UInt8 RGB GMTimage OR a GMTimage{UInt16,3} if the raw option is set to true.\n\nExample:\n\nMake an RGB composite from data in the cube file \"LC08__cube.tiff\"\n\nI = truecolor(\"LC08__cube.tiff\");\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.nbri-Tuple{Any, Any}","page":"Index","title":"RemoteS.nbri","text":"NBRI = nbri(nir, swir3; kw...)\n\nNormalised Burn Ratio Index. Garcia 1991\n\nNBRI = (nir - swir3) / (nir + swir3)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteS.read_mtl","page":"Index","title":"RemoteS.read_mtl","text":"readmtl(bandname::String, mtl::String=\"\"; get_full=false)\n\nUse the band_name of a Landsat8 band to find the MTL file with the scene parameters at which that band belongs and read the params needed to compute Brightness temperature, radiance at top of atmosphere, etc. If the MTL file does not lieve next to the band file, send its name via the mtl argument.\n\nThe get_full option makes this function return a tring with contents of the MTL file or nothing if the MTL file is not found.\n\nReturns a tuple with:\n\n(band=band, radmul=radmul, radadd=radadd, radmax=radmax, reflectmul=reflectmul, reflectadd=reflectadd, reflectmax=reflectmax, sunazim=sunazim, sunelev=sunelev, sundis=sunazim, K1=K1, K2=K2)\n\nor a string with MTL contents (or nothing if MTL file is not found)\n\n\n\n\n\n","category":"function"}]
}
