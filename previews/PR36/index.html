<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · RemoteS.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/custom.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RemoteS.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Gallery</span><ul><li><a class="tocitem" href="gallery/Aqua_orbits/remotes_sat_tracks/">Aqua orbits</a></li><li><a class="tocitem" href="gallery/Aqua_sst/remotes_L2_SST/">Aqua SST</a></li><li><a class="tocitem" href="gallery/L8cube_img/remotes_L8_cube_img/">Landsat 8 images</a></li><li><a class="tocitem" href="gallery/L8cube_ndvi/remotes_L8_NDVI/">Landsat 8 NDVI</a></li></ul></li><li class="is-active"><a class="tocitem" href>Index</a><ul class="internal"><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li><li><a class="tocitem" href="#Functions-1"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="RemoteS-1"><a class="docs-heading-anchor" href="#RemoteS-1">RemoteS</a><a class="docs-heading-anchor-permalink" href="#RemoteS-1" title="Permalink"></a></h1><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#RemoteS.clg-Tuple{Any, Any}"><code>RemoteS.clg</code></a></li><li><a href="#RemoteS.clre-Tuple{Any, Any}"><code>RemoteS.clre</code></a></li><li><a href="#RemoteS.cutcube-Tuple{}"><code>RemoteS.cutcube</code></a></li><li><a href="#RemoteS.dn2radiance-Tuple{String}"><code>RemoteS.dn2radiance</code></a></li><li><a href="#RemoteS.dn2reflectance-Tuple{String}"><code>RemoteS.dn2reflectance</code></a></li><li><a href="#RemoteS.dn2temperature-Tuple{String}"><code>RemoteS.dn2temperature</code></a></li><li><a href="#RemoteS.evi-Tuple{Any, Any, Any}"><code>RemoteS.evi</code></a></li><li><a href="#RemoteS.evi2-Tuple{Any, Any}"><code>RemoteS.evi2</code></a></li><li><a href="#RemoteS.gndvi-Tuple{Any, Any}"><code>RemoteS.gndvi</code></a></li><li><a href="#RemoteS.grid_at_sensor"><code>RemoteS.grid_at_sensor</code></a></li><li><a href="#RemoteS.mndwi-Tuple{Any, Any}"><code>RemoteS.mndwi</code></a></li><li><a href="#RemoteS.msavi-Tuple{Any, Any}"><code>RemoteS.msavi</code></a></li><li><a href="#RemoteS.mtci-Tuple{Any, Any, Any}"><code>RemoteS.mtci</code></a></li><li><a href="#RemoteS.nbri-Tuple{Any, Any}"><code>RemoteS.nbri</code></a></li><li><a href="#RemoteS.ndrei1-Tuple{Any, Any}"><code>RemoteS.ndrei1</code></a></li><li><a href="#RemoteS.ndrei2-Tuple{Any, Any}"><code>RemoteS.ndrei2</code></a></li><li><a href="#RemoteS.ndvi-Tuple{Any, Any}"><code>RemoteS.ndvi</code></a></li><li><a href="#RemoteS.ndwi-Tuple{Any, Any}"><code>RemoteS.ndwi</code></a></li><li><a href="#RemoteS.ndwi2-Tuple{Any, Any}"><code>RemoteS.ndwi2</code></a></li><li><a href="#RemoteS.read_mtl"><code>RemoteS.read_mtl</code></a></li><li><a href="#RemoteS.reflectance_surf-Tuple{String}"><code>RemoteS.reflectance_surf</code></a></li><li><a href="#RemoteS.reportbands-Tuple{Any, Int64}"><code>RemoteS.reportbands</code></a></li><li><a href="#RemoteS.satvi-Tuple{Any, Any, Any}"><code>RemoteS.satvi</code></a></li><li><a href="#RemoteS.savi-Tuple{Any, Any}"><code>RemoteS.savi</code></a></li><li><a href="#RemoteS.slavi-Tuple{Any, Any, Any}"><code>RemoteS.slavi</code></a></li><li><a href="#RemoteS.subcube-Tuple{String}"><code>RemoteS.subcube</code></a></li><li><a href="#RemoteS.truecolor-Tuple{Any, Any, Any}"><code>RemoteS.truecolor</code></a></li></ul><h2 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RemoteS.clg-Tuple{Any, Any}" href="#RemoteS.clg-Tuple{Any, Any}"><code>RemoteS.clg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CLG = clg(green, redEdge3; kw...)</code></pre><p>Green cholorphyl index. Wu et al 2012.</p><p>CLG = (redEdge3)/(green)-1 </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.clre-Tuple{Any, Any}" href="#RemoteS.clre-Tuple{Any, Any}"><code>RemoteS.clre</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CLRE = clre(redEdge1, redEdge3; kw...)</code></pre><p>RedEdge cholorphyl index. Clevers and Gitelson 2013.</p><p>CLRE = (redEdge3)/(redEdge1)-1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.cutcube-Tuple{}" href="#RemoteS.cutcube-Tuple{}"><code>RemoteS.cutcube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cutcube(names=String[], bands=Int[], template=&quot;&quot;, region=nothing, extension=&quot;.TIF&quot;, description=String[], mtl=&quot;&quot;, sentinel2=0, save=&quot;&quot;)</code></pre><p>Cut a 3D cube out of a Landsat/Sentinel scene within a subregion <code>region</code> and a selection of bands.</p><ul><li><code>names</code>: (optional) A vector with the individual bands full file name</li><li><code>bands</code>: When <code>names</code> is not provided give a vector of integers corresponding to the choosen bands.          This works well for Landsat and most of Sentinel bands. However, in later case, there are also          bands that contain characters, for example band 8A. In this case <code>bands</code> should be a vector of          strings including the extension. <em>e.g.</em> [&quot;02.jp2&quot;, &quot;8A.jp2&quot;]</li><li><code>template</code>: Goes together with the <code>bands</code> option. They are both composed a template * band[n] to recreate          the full file name of each band.</li><li><code>region</code> Is the region to extract and must contain the extracting region limits as [W, E, S, N] or a          GMT style -R string (without the leading &quot;-R&quot;).</li><li><code>extension</code>: In case the <code>bands</code> is numeric but file extensions are not &quot;*.TIF&quot; (case insensitive),          use the extension passed by this option.</li><li><code>description</code>: A vector of strings (as many as bands) with a description for each band. If not provided and          the file is recognized as a Landasat 8, band description is added automatically, otherwise          we build one with the bands file names. This info will saved if data is written to a file.</li><li><code>mtl</code>:   If reading from Landsat and the MTL file is not automatically found (you get an error) use this          option to pass the full name of the MTL file.</li><li><code>sentinel2</code>: ESA is just unconsistent and names change with time and band numbers can have character (e.g. 8A)          hence we need help to recognize Sentinel files so the known description can be assigned.          Use <code>sentinel=10</code>, or <code>=20</code> or <code>=60</code> to indicate Sentinel files at those resolutions.</li><li><code>save</code>:  The file name where to save the output. If not provided, a GMTimage is returned.</li></ul><p>Return: <code>nothing</code> if the result is written in file or a GMTimage otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Cut a Landsat 8 scene for a small region (in UTM) and return a GMTimage with 3 bands in UInt16.
temp = &quot;C:\SIG_AnaliseDadosSatelite\SIG_ADS\DadosEx2\LC82040332015145LGN00\LC82040332015145LGN00_B&quot;;
cube = cutcube(bands=[2,3,4], template=temp, region=[479670,492720,4282230,4294500])

# The same example as above but save the data in a GeoTIFF disk file and use a string for `region`
cutcube(bands=[2,3,4], template=temp, region=&quot;479670/492720/4282230/4294500&quot;, save=&quot;landsat_cube.tif&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/utils.jl#L271-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.dn2radiance-Tuple{String}" href="#RemoteS.dn2radiance-Tuple{String}"><code>RemoteS.dn2radiance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R = dn2radiance(fname::String, [band::Int, bandname::String, mtl::String, save::String])</code></pre><p>Computes the radiance at TopOfAtmosphere of a Landsat 8 file</p><ul><li><code>fname</code>: The name of either a <span>$LANDSAT_PRODUCT_ID$</span> geotiff band, or the name of a cube file created with the <code>cutcube</code> function. In the first case, if the companion <span>$...MTL.txt$</span> file is not in the same directory as <code>fname</code> one can still pass it via the <code>mtl=path-to-MTL-file</code> option. In the second case it is mandatory to use one of the following two options.</li><li><code>band</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>band</code> is used we search for the band named &quot;Band N&quot;, where N = <code>band</code>.</li><li><code>bandname</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandname</code> string that will be matched against the cube&#39;s bands descriptions. We can use the <code>reportbands</code> function to see the bands description.</li><li><code>save</code>:  The file name where to save the output. If not provided, a GMTgrid is returned.</li></ul><p>Returns a Float32 GMTgrid</p><p><strong>Example:</strong></p><p>Compute the radiance TOA of Band 2 file.</p><pre><code class="language-none">R = dn2temperature(&quot;LC08_L1TP_204033_20210525_20210529_02_T1_B2.TIF&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/utils.jl#L564-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.dn2reflectance-Tuple{String}" href="#RemoteS.dn2reflectance-Tuple{String}"><code>RemoteS.dn2reflectance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R = dn2reflectance(fname::String, [band::Int, bandname::String, mtl::String, save::String])</code></pre><p>Computes the TopOfAtmosphere planetary reflectance of a Landsat8 file</p><ul><li><code>fname</code>: The name of either a <span>$LANDSAT_PRODUCT_ID$</span> geotiff band, or the name of a cube file created with the <code>cutcube</code> function. In the first case, if the companion <span>$...MTL.txt$</span> file is not in the same directory as <code>fname</code> one can still pass it via the <code>mtl=path-to-MTL-file</code> option. In the second case it is mandatory to use one of the following two options.</li><li><code>band</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>band</code> is used we search for the band named &quot;Band N&quot;, where N = <code>band</code>.</li><li><code>bandname</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandname</code> string that will be matched against the cube&#39;s bands descriptions. We can use the <code>reportbands</code> function to see the bands description.</li><li><code>save</code>:  The file name where to save the output. If not provided, a GMTgrid is returned.</li></ul><p>Returns a Float32 GMTgrid</p><p><strong>Example:</strong></p><p>Compute the reflectance TOA of Red Band stored in a <code>cube</code></p><pre><code class="language-none">R = dn2reflectance(cube, bandname=&quot;red&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/utils.jl#L582-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.dn2temperature-Tuple{String}" href="#RemoteS.dn2temperature-Tuple{String}"><code>RemoteS.dn2temperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R = dn2temperature(fname::String; band::Int=0, mtl::String=&quot;&quot;, save::String)</code></pre><p>Computes the brigthness temperature of Landasat8 termal band (10 or 11)</p><ul><li><code>fname</code>: The name of either a <span>$LANDSAT_PRODUCT_ID$</span> geotiff band, or the name of a cube file created with the <code>cutcube</code> function. In the first case, if the companion <span>$...MTL.txt$</span> file is not in the same directory as <code>fname</code> one can still pass it via the <code>mtl=path-to-MTL-file</code> option. In the second case it is mandatory to use one of the following two options.</li><li><code>band</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>band</code> is used we search for the band named &quot;Band N&quot;, where N = <code>band</code>.</li><li><code>bandname</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandname</code> string that will be matched against the cube&#39;s bands descriptions. We can use the <code>reportbands</code> function to see the bands description.</li><li><code>save</code>:  The file name where to save the output. If not provided, a GMTgrid is returned.</li></ul><p>Returns a Float32 GMTgrid</p><p><strong>Example:</strong></p><p>Compute the brightness temperature of Band 10 stored in a <code>cube</code></p><pre><code class="language-none">T = dn2temperature(cube, band=10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/utils.jl#L524-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.evi-Tuple{Any, Any, Any}" href="#RemoteS.evi-Tuple{Any, Any, Any}"><code>RemoteS.evi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">EVI = evi(blue, red, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">EVI = evi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Enhanced vegetation index. Huete et al 1990</p><p>EVI = G * ((nir - red) / (nir + C1 * red - C2 * blue + Levi)); C1, C2, G, Levi = 6.0, 7.5, 2.5, 1.</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The second form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band band[k]&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li><li><code>kwargs</code>:<ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li></ul></li></ul><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L62-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.evi2-Tuple{Any, Any}" href="#RemoteS.evi2-Tuple{Any, Any}"><code>RemoteS.evi2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">EVI2 = evi2(red, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">EVI2 = evi2(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Two-band Enhanced vegetation index. Jiang et al 2008</p><p>EVI2 = G * ((nir - red) / (nir + 2.4 * red ))</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The second form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band band[k]&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li><li><code>kwargs</code>:<ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li></ul></li></ul><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L82-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.gndvi-Tuple{Any, Any}" href="#RemoteS.gndvi-Tuple{Any, Any}"><code>RemoteS.gndvi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GNDVI = gndvi(green, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">GNDVI = gndvi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>green Normalized diff vegetation index: more sensitive to cholorphyll than ndvi. Gitelson, A., and M. Merzlyak</p><p>GNDVI = (nir - green) / (nir + green)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The second form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band band[k]&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li><li><code>kwargs</code>:<ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li></ul></li></ul><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L100-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.grid_at_sensor" href="#RemoteS.grid_at_sensor"><code>RemoteS.grid_at_sensor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">G = grid_at_sensor(fname::String, sds_name::String=&quot;&quot;; V::Bool=false, kw...)</code></pre><p>Read one of those netCDF files that are not regular grids but have instead the coordinates in the LONGITUDE abd LATITUDE arrays. MODIS L2 files are a good example of this. Data in theses files are not layed down on a regular grid and we must interpolate to get one. Normally the lon and lat arrays are called &#39;longitude&#39; and &#39;latitude&#39; and these it&#39;s what is seek for by default. But files exist that pretend to comply to CF but use other names. In this case, use the kwargs <code>xarray</code> &amp; <code>yarray</code> to pass in the variable names. For example: <code>xarray=&quot;XLONG&quot;</code>, <code>yarray=&quot;XLAT&quot;</code> The other fundamental info to pass in is the name of the array to be read/interpolated. We do that via the <code>sds_name</code> arg.</p><p>In simpler cases the variable to be interpolated lays down on a 2D array but it is also possible that it is stored in a 3D array. If that is the case, use the keyword &#39;band&#39; to select a band (ex: &#39;band=2&#39;) Bands are numbered from 1.</p><p>The interpolation is done so far with &#39;nearneighbor&#39;. Both the region (-R) and increment (-I) are estimated from data but they can be set with <code>region</code> and <code>inc</code> kwargs as well. For MODIS data we can select the quality flag to filter by data quality. By default the best quality (=0) is used, but one can select another with the <code>quality=val</code> kwarg. Positive &#39;val&#39; values select data of quality &lt;= quality, whilst negative &#39;val&#39; values select only data with quality &gt;= abs(val). This allows for example to extract only the cloud coverage.</p><p>If instead of calculating a grid (returned as a GMTgrid type) user wants the x,y,z data intself, use the keywords <code>dataset</code>, or <code>outxyz</code> and the output will be in a GMTdataset (i.e. use <code>dataset=true</code>).</p><p>To inquire just the list of available arrays use <code>list=true</code> or <code>gdalinfo=true</code> to get the full file info.</p><pre><code class="language-none">Examples:

G = grid_at_sensor(&quot;AQUA_MODIS.20020717T135006.L2.SST.nc&quot;, &quot;sst&quot;, V=true);

G = grid_at_sensor(&quot;TXx-narr-annual-timavg.nc&quot;, &quot;T2MAX&quot;, xarray=&quot;XLONG&quot;, yarray=&quot;XLAT&quot;, V=true);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/grid_at_sensor.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.mndwi-Tuple{Any, Any}" href="#RemoteS.mndwi-Tuple{Any, Any}"><code>RemoteS.mndwi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MNDWI = mndwi(green, swir2; kw...)</code></pre><p>or</p><pre><code class="language-none">MNDWI = mndwi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Modified Normalised Difference Water Index. Xu2006</p><p>MNDWI = (green-swir2) / (green+swir2)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The second form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band band[k]&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li><li><code>kwargs</code>:<ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li></ul></li></ul><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L118-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.msavi-Tuple{Any, Any}" href="#RemoteS.msavi-Tuple{Any, Any}"><code>RemoteS.msavi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MSAVI = msavi(red, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">MSAVI = msavi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Modified soil adjusted vegetation index. Qi 1994</p><p>MSAVI = nir + 0.5 - (0.5 * sqrt(pow(2.0 * nir + 1.0, 2) - 8.0 * (nir - (2.0 * red))))</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The second form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band band[k]&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li><li><code>kwargs</code>:<ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li></ul></li></ul><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L159-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.mtci-Tuple{Any, Any, Any}" href="#RemoteS.mtci-Tuple{Any, Any, Any}"><code>RemoteS.mtci</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MTCI = mtci(red, redEdge1, redEdge2; kw...)</code></pre><p>Meris Terrestrial Chlorophyll Index. Clevers and Gitelson 2013, Dash and Curran 2004</p><p>MTCI = (redEdge2-redEdge1) / (redEdge1-red)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L136-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.ndrei1-Tuple{Any, Any}" href="#RemoteS.ndrei1-Tuple{Any, Any}"><code>RemoteS.ndrei1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NDREI1 = ndrei1(redEdge1, redEdge2; kw...)</code></pre><p>Normalized difference red edge index. Gitelson and Merzlyak 1994</p><p>NDREI1 = (redEdge2 - redEdge1) / (redEdge2 + redEdge1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L244-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.ndrei2-Tuple{Any, Any}" href="#RemoteS.ndrei2-Tuple{Any, Any}"><code>RemoteS.ndrei2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NDREI2 = ndrei2(redEdge1, redEdge3; kw...)</code></pre><p>Normalized difference red edge index 2. Barnes et al 2000</p><p>NDREI2 = (redEdge3 - redEdge1) / (redEdge3 + redEdge1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L255-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.ndvi-Tuple{Any, Any}" href="#RemoteS.ndvi-Tuple{Any, Any}"><code>RemoteS.ndvi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NDVI = ndvi(red, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">NDVI = ndvi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Compute the NDVI vegetation index. Input can be either the bands file names, or GMTimage objects with the band&#39;s data.</p><p>NDVI = (nir - red) / (nir + red)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The second form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band band[k]&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li><li><code>kwargs</code>:<ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li></ul></li></ul><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L188-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.ndwi-Tuple{Any, Any}" href="#RemoteS.ndwi-Tuple{Any, Any}"><code>RemoteS.ndwi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NDWI = ndwi(green, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">NDWI = ndwi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Normalized difference water index. McFeeters 1996. NDWI =&gt; (green - nir)/(green + nir)</p><p>NDWI = (green - nir)/(green + nir)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The second form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band band[k]&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li><li><code>kwargs</code>:<ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li></ul></li></ul><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L207-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.ndwi2-Tuple{Any, Any}" href="#RemoteS.ndwi2-Tuple{Any, Any}"><code>RemoteS.ndwi2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NDWI2 = ndwi2(nir, swir2; kw...)</code></pre><p>or</p><pre><code class="language-none">NDWI2 = ndwi2(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Normalized difference water index. Gao 1996, Chen 2005 (also known as Normalized Difference Moisture Index NDBI and LSWI)</p><p>NDWI2 = (nir - swir2)/(nir + swir2)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The second form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band band[k]&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li><li><code>kwargs</code>:<ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li></ul></li></ul><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L225-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.reflectance_surf-Tuple{String}" href="#RemoteS.reflectance_surf-Tuple{String}"><code>RemoteS.reflectance_surf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R = reflectance_surf(fname::String, [band::Int, bandname::String, mtl::String, save::String])</code></pre><p>Computes the radiance-at-surface of Landsat8 band using the COST model.</p><ul><li><code>fname</code>: The name of either a <span>$LANDSAT_PRODUCT_ID$</span> geotiff band, or the name of a cube file created with the <code>cutcube</code> function. In the first case, if the companion <span>$...MTL.txt$</span> file is not in the same directory as <code>fname</code> one can still pass it via the <code>mtl=path-to-MTL-file</code> option. In the second case it is mandatory to use one of the following two options.</li><li><code>band</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>band</code> is used we search for the band named &quot;Band N&quot;, where N = <code>band</code>.</li><li><code>bandname</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandname</code> string that will be matched against the cube&#39;s bands descriptions. We can use the <code>reportbands</code> function to see the bands description.</li><li><code>save</code>:  The file name where to save the output. If not provided, a GMTgrid is returned.</li></ul><p>Returns a Float32 GMTgrid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/utils.jl#L639-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.reportbands-Tuple{Any, Int64}" href="#RemoteS.reportbands-Tuple{Any, Int64}"><code>RemoteS.reportbands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reportbands(in; [layers=Int[]])</code></pre><p>or</p><pre><code class="language-none">reportbands(in, layer;)</code></pre><p>Report the Bands description of the <code>in</code> input argument. This can be a GMTimage, a GMTgrid or a file name (a String) of  a &#39;cube&#39; file. Normally one made with the <code>cutcube</code> function. When the use conditions of this function are not met, either a warning or an error message (if too deep to be caught as a warning) will be issued.</p><ul><li><code>layers</code>: When this optional parameter is used, report the description of the bands in the vector <code>layers</code></li><li><code>layer</code>: A scalar with a unique band number. Alternative form to <code>reportbands(in, layers=[layer])</code></li></ul><p>Returns a string vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/utils.jl#L242-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.satvi-Tuple{Any, Any, Any}" href="#RemoteS.satvi-Tuple{Any, Any, Any}"><code>RemoteS.satvi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SATVI = satvi(red, swir2, swir3; kw...)</code></pre><p>Soil adjusted total vegetation index. Marsett 2006</p><p>SATVI = ((swir1 - red) / (swir1 + red + L)) * (1.0 + L) - (swir2 / 2.0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L266-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.savi-Tuple{Any, Any}" href="#RemoteS.savi-Tuple{Any, Any}"><code>RemoteS.savi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SAVI = savi(red, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">SAVI = savi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Soil adjusted vegetation index. Huete 1988</p><p>SAVI = (nir - red) * (1.0 + L) / (nir + red + L)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The second form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band band[k]&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li><li><code>kwargs</code>:<ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li></ul></li></ul><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L279-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.slavi-Tuple{Any, Any, Any}" href="#RemoteS.slavi-Tuple{Any, Any, Any}"><code>RemoteS.slavi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SLAVI = slavi(red, nir, swir2; kw...)</code></pre><p>or</p><pre><code class="language-none">SLAVI = slavi(cube::String; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Specific Leaf Area Vegetation Index. Lymburger 2000</p><p>SLAVI = nir / (red + swir2)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The second form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band band[k]&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li><li><code>kwargs</code>:<ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li></ul></li></ul><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L297-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.subcube-Tuple{String}" href="#RemoteS.subcube-Tuple{String}"><code>RemoteS.subcube</code></a> — <span class="docstring-category">Method</span></header><section><div><p>subcube(cube::String; bands=Int[], bandnames=String[], layers=Int[])</p><p>Extracts a subcube from <code>cube</code> with the layers in the <code>bands</code> vector, case in which we will search for bands named &quot;Band band[k]&quot;, or those whose names correspond (even partially and case insensitive) to the descriptions in <code>bandnames</code> string vector. This means that the options <code>bands</code> and <code>bandnames</code> can only be used in &#39;cubes&#39; with bands description. The <code>layers</code> option blindly extract the <code>cube</code> planes listed in the <code>layer</code> vector.</p><p>Returns a GMTimage</p><p><strong>Example</strong></p><p>Extracts the Red, Green and Blue layers from a Landsat 8 cube created with <code>cutcube</code></p><pre><code class="language-none">Irgb = subcube(&quot;LC08__cube.tiff&quot;, bandnames = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/utils.jl#L143-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.truecolor-Tuple{Any, Any, Any}" href="#RemoteS.truecolor-Tuple{Any, Any, Any}"><code>RemoteS.truecolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Irgb = truecolor(bndR, bndG, bndB)</code></pre><p>Take three Landsat8/Sentinel2 UINT16 GMTimages or the file names of those bands and compose an RGB true color image applying automatic histogram stretching.</p><p>Return an UInt8 RGB GMTimage</p><pre><code class="language-none">Irgb = truecolor(cube::GMTImage, bands::Vector{Int})</code></pre><p>Make an RGB composition of the 3 bands passed in the vector &#39;bands&#39; from the layers in the multi-layered GMTimage <code>cube</code></p><p>Return an auto-stretched UInt8 RGB GMTimage</p><pre><code class="language-none">Irgb = truecolor(cube::String, [bands::Vector{Int}], [bandnames::Vector{String}], [raw=false])</code></pre><p>Make an RGB composition of 3 bands from the <code>cube</code> file holding a UInt16 multi-layered array (often created with <code>cutcube</code>) The band selection can be made with <code>bands</code> vector, case in which we will search for bands named &quot;Band band[k]&quot; or where the bands description contain the contents of <code>bandnames</code>. If none of <code>bands</code> or <code>bandnames</code> is used we search for a made up <code>bandnames=[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</code>.</p><p>Return an auto-stretched UInt8 RGB GMTimage OR a GMTimage{UInt16,3} if the <code>raw</code> option is set to <code>true</code>.</p><p><strong>Example:</strong></p><p>Make an RGB composite from data in the cube file &quot;LC08__cube.tiff&quot;</p><pre><code class="language-julia">I = truecolor(&quot;LC08__cube.tiff&quot;);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/utils.jl#L52-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.nbri-Tuple{Any, Any}" href="#RemoteS.nbri-Tuple{Any, Any}"><code>RemoteS.nbri</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NBRI = nbri(nir, swir3; kw...)</code></pre><p>Normalised Burn Ratio Index. Garcia 1991</p><p>NBRI = (nir - swir3) / (nir + swir3)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/spectral_indices.jl#L177-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.read_mtl" href="#RemoteS.read_mtl"><code>RemoteS.read_mtl</code></a> — <span class="docstring-category">Function</span></header><section><div><p>read<em>mtl(band</em>name::String, mtl::String=&quot;&quot;; get_full=false)</p><p>Use the <code>band_name</code> of a Landsat8 band to find the MTL file with the scene parameters at which that band belongs and read the params needed to compute Brightness temperature, radiance at top of atmosphere, etc. If the MTL file does not lieve next to the band file, send its name via the <code>mtl</code> argument.</p><p>The <code>get_full</code> option makes this function return a tring with contents of the MTL file or <code>nothing</code> if the MTL file is not found.</p><p><strong>Returns a tuple with:</strong></p><p>(band=band, rad<em>mul=rad</em>mul, rad<em>add=rad</em>add, rad<em>max=rad</em>max, reflect<em>mul=reflect</em>mul, reflect<em>add=reflect</em>add, reflect<em>max=reflect</em>max, sun<em>azim=sun</em>azim, sun<em>elev=sun</em>elev, sun<em>dis=sun</em>azim, K1=K1, K2=K2)</p><p>or a string with MTL contents (or nothing if MTL file is not found)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/64e837abff05739de6f7fb643d562fbd3b1fd96f/src/utils.jl#L384-L399">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="gallery/L8cube_ndvi/remotes_L8_NDVI/">« Landsat 8 NDVI</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 14 November 2021 00:17">Sunday 14 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
